/* SimpleDBMSParser.java */
/* Generated By:JavaCC: Do not edit this line. SimpleDBMSParser.java */
package kr.ac.snu.ids;

import kr.ac.snu.ids.db.BerKeleyDB;
import kr.ac.snu.ids.db.ComparableValue;
import kr.ac.snu.ids.db.DataDefinitionManager;
import kr.ac.snu.ids.db.QueryManager;
import kr.ac.snu.ids.definition.*;
import kr.ac.snu.ids.exceptions.DefinitionError;
import kr.ac.snu.ids.exceptions.NoSuchTableError;
import kr.ac.snu.ids.query.*;
import kr.ac.snu.ids.query.predicate.*;

import java.util.ArrayList;
import java.util.List;

public class SimpleDBMSParser implements SimpleDBMSParserConstants {
    public static final int PRINT_SYNTAX_ERROR = 0;

    public static final int PRINT_CREATE_TABLE = 1;

    public static final int PRINT_DROP_TABLE = 2;

    public static final int PRINT_DESC = 3;

    public static final int PRINT_SHOW_TABLES = 4;

    public static final int PRINT_INSERT_QUERY = 5;

    public static final int PRINT_DELETE_QUERY = 6;

    public static final int PRINT_SELECT_QUERY = 7;

    public static void main(String[] args) throws ParseException {

        SimpleDBMSParser parser = new SimpleDBMSParser(System.in);
        System.out.print("DB_2018-15366> ");
        while (true) {
            try {
                SimpleDBMSParser.command();
            }
            catch (Exception e) {
                printMessage("Syntax error", true);
                SimpleDBMSParser.ReInit(System.in);
            }
        }
    }

    /**
    * query의 종류에 대응하는 메세지를 콘솔에 출력한다
    * lastLine은 유저의 queryList 입력이 끝난 경우 true이며 이때 콘솔에 prompt를 출력한다.
    */
    public static void printMessage(String q, boolean lastLine) {
        if (!q.isEmpty()) System.out.println(q);
        if (lastLine)
            System.out.print("DB_2018-15366> ");
    }

  static final public void command() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case CREATE:
        case DROP:
        case DESC:
        case SHOW:
        case INSERT:
        case DELETE:
        case SELECT: {
            queryList();
            break;
        }
        case EXIT: {
            jj_consume_token(EXIT);
            if (jj_2_1(2147483647)) {
                jj_consume_token(NEWLINE);
            } else {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case SEMICOLON: {
                        jj_consume_token(SEMICOLON);
                        break;
                    }
                    default:
                        jj_la1[0] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
            BerKeleyDB.closeDatabase();
            System.exit(0);
            break;
        }
        default:
            jj_la1[1] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
    }
}

/**
* 유저의 Query List 입력 ( queries .... + "\n")을 처리한다.
*/
  static final public void queryList() throws ParseException {String q;
    label_1:
    while (true) {
      q = query();
      if (jj_2_2(2147483647)) {
        jj_consume_token(NEWLINE);
printMessage(q, true);
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SEMICOLON:{
          jj_consume_token(SEMICOLON);
printMessage(q, false);
          break;
          }
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case CREATE:
          case DROP:
          case DESC:
          case SHOW:
          case INSERT:
          case DELETE:
          case SELECT: {
              ;
              break;
          }
          default:
              jj_la1[3] = jj_gen;
              break label_1;
      }
    }
}

  static final public String query() throws ParseException {String message;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case CREATE: {
            message = createTableQuery();
            break;
        }
        case DROP: {
            message = dropTableQuery();
            break;
        }
        case DESC: {
            message = descTableQuery();
            break;
        }
        case SHOW: {
            message = showTableQuery();
            break;
        }
        case INSERT: {
            message = insertQuery();
            break;
        }
        case SELECT: {
            message = selectQuery();
            break;
        }
        case DELETE: {
            message = deleteQuery();
            break;
        }
        default:
            jj_la1[4] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
    }
      {
          if ("" != null) return message;
      }
      throw new Error("Missing return statement in function");
  }

    static final public String createTableQuery() throws ParseException {
        TableDefinition tableInfo;
        TableDefinition.Builder builder = new TableDefinition.Builder();
        String _tableName;
        String message;
        jj_consume_token(CREATE);
        jj_consume_token(TABLE);
        _tableName = tableName();
        tableElementList(builder);
        try {
            tableInfo = builder
                    .setTableName(_tableName)
                    .create();
            DataDefinitionManager.createSchema(tableInfo);

            message = String.format("'%s' table is created", _tableName);
        } catch (DefinitionError e) {
            message = e.getMessage();
        }
        {
            if ("" != null) return message;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String dropTableQuery() throws ParseException {
        String message;
        String _tableName;
        jj_consume_token(DROP);
        jj_consume_token(TABLE);
        _tableName = tableName();
        try {
            DataDefinitionManager.dropSchema(_tableName);
            message = String.format("'%s' table is dropped", _tableName);
        } catch (DefinitionError e) {
            message = e.getMessage();
        }
        {
            if ("" != null) return message;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String descTableQuery() throws ParseException {
        String _tableName;
        String message;
        jj_consume_token(DESC);
        _tableName = tableName();
        try {
            message = DataDefinitionManager.getSchema(_tableName).toString();
        } catch (NoSuchTableError e) {
            message = e.getMessage();
        }
        {
            if ("" != null) return message;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String showTableQuery() throws ParseException {
        String message;
        jj_consume_token(SHOW);
        jj_consume_token(TABLES);
        List<String> names = DataDefinitionManager.getTableNames();
        if (names.isEmpty()) {
            message = "There is no table";
        } else {
            message = "----------------\n";
            message += String.join("\n", names);
            message += "\n----------------";
        }
        {
            if ("" != null) return message;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String insertQuery() throws ParseException {
        InsertQuery.Builder builder = new InsertQuery.Builder();
        String _tableName;
        jj_consume_token(INSERT);
        jj_consume_token(INTO);
        _tableName = tableName();
        insertColumnsAndSource(builder);
        String message;
        try {
            InsertQuery query = builder.setTableName(_tableName)
                    .create();
            QueryManager.insertQuery(query);
            message = "The row is inserted";
        } catch (DefinitionError e) {
            message = e.getMessage();
        }
        {
            if ("" != null) return message;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String deleteQuery() throws ParseException {
        String _tableName;
        BooleanCondition _condition = null;
        jj_consume_token(DELETE);
        jj_consume_token(FROM);
        _tableName = tableName();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case WHERE: {
                _condition = whereClause();
                break;
            }
            default:
                jj_la1[5] = jj_gen;
                ;
        }
        String message = null;
        DeleteQuery.Builder builder = new DeleteQuery.Builder();
        try {
            DeleteQuery query = builder.setTableName(_tableName)
                    .setCondition(_condition)
                    .create();
            int deleteNum = QueryManager.deleteQuery(query);
            message = String.format("%d row(s) are deleted", deleteNum);
        } catch (DefinitionError e) {
            message = e.getMessage();
        }
        {
            if ("" != null) return message;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String selectQuery() throws ParseException {
        SelectQuery.Builder builder = new SelectQuery.Builder();
        List<ColumnReference> _selectList;
        List<TableReference> _tableReferenceList;
        BooleanCondition _condition = null;
        jj_consume_token(SELECT);
        _selectList = selectList();
        jj_consume_token(FROM);
        _tableReferenceList = tableReferenceList();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case WHERE: {
                _condition = whereClause();
                break;
            }
            default:
                jj_la1[6] = jj_gen;
                ;
        }
        String message = null;
        try {
            SelectQuery query = builder.setColumnReferenceList(_selectList)
                    .setTableReferenceList(_tableReferenceList)
                    .setCondition(_condition)
                    .create();
            QueryManager.selectQuery(query);
            {
                if ("" != null) return "";
            }
        } catch (DefinitionError e) {
            message = e.getMessage();
        }
        {
            if ("" != null) return message;
        }
        throw new Error("Missing return statement in function");
    }

    static final public List<ColumnReference> selectList() throws ParseException {
        List<ColumnReference> _selectList = new ArrayList<>();
        ColumnReference _selectedColumn;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case ASTERISK: {
                jj_consume_token(ASTERISK);
                _selectList.add(new ColumnReference("*", null, null));
                break;
            }
            case LEGAL_IDENTIFIER: {
                _selectedColumn = selectedColumn();
                _selectList.add(_selectedColumn);
                label_2:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                        case COMMA: {
                            ;
                            break;
                        }
                        default:
                            jj_la1[7] = jj_gen;
                            break label_2;
                    }
                    jj_consume_token(COMMA);
                    _selectedColumn = selectedColumn();
                    _selectList.add(_selectedColumn);
                }
                break;
            }
            default:
                jj_la1[8] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) return _selectList;
        }
        throw new Error("Missing return statement in function");
    }

    static final public ColumnReference selectedColumn() throws ParseException {
        String _tableName = null;
        String _columnName = null;
        String _alias = null;
        if (jj_2_3(2)) {
            _tableName = tableName();
            jj_consume_token(PERIOD);
        } else {
            ;
        }
        _columnName = columnName();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case AS: {
                jj_consume_token(AS);
                _alias = columnName();
                break;
            }
            default:
                jj_la1[9] = jj_gen;
                ;
        }
        {
            if ("" != null) return new ColumnReference(_columnName, _tableName, _alias);
        }
        throw new Error("Missing return statement in function");
    }

    static final public List<TableReference> tableReferenceList() throws ParseException {
        List<TableReference> _tableReferenceList = new ArrayList<>();
        TableReference _referedTable;
        _referedTable = referedTable();
        _tableReferenceList.add(_referedTable);
        label_3:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case COMMA: {
                    ;
                    break;
                }
                default:
                    jj_la1[10] = jj_gen;
                    break label_3;
            }
            jj_consume_token(COMMA);
            _referedTable = referedTable();
            _tableReferenceList.add(_referedTable);
        }
        {
            if ("" != null) return _tableReferenceList;
        }
        throw new Error("Missing return statement in function");
    }

    static final public TableReference referedTable() throws ParseException {
        String _tableName = null;
        String _alias = null;
        _tableName = tableName();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case AS: {
                jj_consume_token(AS);
                _alias = tableName();
                break;
            }
            default:
                jj_la1[11] = jj_gen;
                ;
        }
        {
            if ("" != null) return new TableReference(_tableName, _alias);
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanCondition whereClause() throws ParseException {
        BooleanCondition _cond;
        jj_consume_token(WHERE);
        _cond = booleanValueExpression();
        {
            if ("" != null) return _cond;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanCondition booleanValueExpression() throws ParseException {
        BooleanValueExpression _expression = new BooleanValueExpression();
        BooleanCondition _cond;
        _cond = booleanTerm();
        _expression.addTerm(_cond);
        label_4:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case OR: {
                    ;
                    break;
                }
                default:
                    jj_la1[12] = jj_gen;
                    break label_4;
            }
            jj_consume_token(OR);
            _cond = booleanTerm();
            _expression.addTerm(_cond);
        }
        {
            if ("" != null) return _expression;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanCondition booleanTerm() throws ParseException {
        BooleanTerm _term = new BooleanTerm();
        BooleanCondition _cond;
        _cond = booleanFactor();
        _term.addFactor(_cond);
        label_5:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case AND: {
                    ;
                    break;
                }
                default:
                    jj_la1[13] = jj_gen;
                    break label_5;
            }
            jj_consume_token(AND);
            _cond = booleanFactor();
            _term.addFactor(_cond);
        }
        {
            if ("" != null) return _term;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanCondition booleanFactor() throws ParseException {
        BooleanFactor _factor = new BooleanFactor();
        BooleanCondition _cond;
        _factor.setNot(false);
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case NOT: {
                jj_consume_token(NOT);
                _factor.setNot(true);
                break;
            }
            default:
                jj_la1[14] = jj_gen;
                ;
        }
        _cond = booleanTest();
        _factor.setTest(_cond);
        {
            if ("" != null) return _factor;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanCondition booleanTest() throws ParseException {
        BooleanCondition _cond;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case INT_VALUE:
            case DATE_VALUE:
            case CHAR_STRING:
            case LEGAL_IDENTIFIER: {
                _cond = predicate();
                break;
            }
            case LEFT_PAREN: {
                _cond = parenthesizedBooleanExpression();
                break;
            }
            default:
                jj_la1[15] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) return _cond;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanCondition parenthesizedBooleanExpression() throws ParseException {
        BooleanCondition _cond;
        jj_consume_token(LEFT_PAREN);
        _cond = booleanValueExpression();
        jj_consume_token(RIGHT_PAREN);
        {
            if ("" != null) return _cond;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanCondition predicate() throws ParseException {
        BooleanCondition _cond;
        if (jj_2_4(4)) {
            _cond = comparisonPredicate();
        } else {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case LEGAL_IDENTIFIER: {
                    _cond = nullPredicate();
                    break;
                }
                default:
                    jj_la1[16] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        {
            if ("" != null) return _cond;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanCondition comparisonPredicate() throws ParseException {
        ComparisonPredicate _comp = new ComparisonPredicate();
        ComparableValue left;
        ComparableValue right;
        String operator;
        left = compOperand();
        _comp.setLeft(left);
        operator = compOp();
        _comp.setOperator(operator);
        right = compOperand();
        _comp.setRight(right);
        {
            if ("" != null) return _comp;
        }
        throw new Error("Missing return statement in function");
    }

    static final public ComparableValue compOperand() throws ParseException {
        ComparableValue _val;
        String _tableName;
        String _columnName;
        String tabcol = "";
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case INT_VALUE:
            case DATE_VALUE:
            case CHAR_STRING: {
                _val = comparableValue();
                break;
            }
            case LEGAL_IDENTIFIER: {
                if (jj_2_5(2)) {
                    _tableName = tableName();
                    tabcol = _tableName.concat(".");
                    jj_consume_token(PERIOD);
                } else {
                    ;
                }
                _columnName = columnName();
                tabcol = tabcol.concat(_columnName);
                _val = new ComparableValue(DataType.TABLECOL, tabcol);
                break;
            }
            default:
                jj_la1[17] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) return _val;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String compOp() throws ParseException {
        Token t;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case INEQ_S: {
                t = jj_consume_token(INEQ_S);
                break;
            }
            case INEQ_SE: {
                t = jj_consume_token(INEQ_SE);
                break;
            }
            case INEQ_B: {
                t = jj_consume_token(INEQ_B);
                break;
            }
            case INEQ_BE: {
                t = jj_consume_token(INEQ_BE);
                break;
            }
            case INEQ_E: {
                t = jj_consume_token(INEQ_E);
                break;
            }
            case INEQ_NE: {
                t = jj_consume_token(INEQ_NE);
                break;
            }
            default:
                jj_la1[18] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) return t.toString();
        }
        throw new Error("Missing return statement in function");
    }

    static final public ComparableValue comparableValue() throws ParseException {
        Token t;
        ComparableValue _v;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case INT_VALUE: {
                t = jj_consume_token(INT_VALUE);
                {
                    if ("" != null) return new ComparableValue(DataType.INTEGER, t.toString());
                }
                break;
            }
            case CHAR_STRING: {
                t = jj_consume_token(CHAR_STRING);
                {
                    if ("" != null) return new ComparableValue(DataType.CHARACTER, t.toString().replace("'", ""));
                }
                break;
            }
            case DATE_VALUE: {
                t = jj_consume_token(DATE_VALUE);
                {
                    if ("" != null) return new ComparableValue(DataType.DATE, t.toString());
                }
                break;
            }
            default:
                jj_la1[19] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanCondition nullPredicate() throws ParseException {
        NullPredicate _nullpred = new NullPredicate();
        String _tableName = null;
        String _columnName;
        Boolean _null;
        if (jj_2_6(2)) {
            _tableName = tableName();
            jj_consume_token(PERIOD);
        } else {
            ;
        }
        _columnName = columnName();
        _null = nullOperation();
        _nullpred.setTableName(_tableName);
        _nullpred.setColName(_columnName);
        _nullpred.setNull(_null);

        {
            if ("" != null) return _nullpred;
        }
        throw new Error("Missing return statement in function");
    }

    static final public Boolean nullOperation() throws ParseException {
        jj_consume_token(IS);
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case NOT_NULL: {
                jj_consume_token(NOT_NULL);
                {
                    if ("" != null) return false;
                }
                break;
            }
            case NULL: {
                jj_consume_token(NULL);
                {
                    if ("" != null) return true;
                }
                break;
            }
            default:
                jj_la1[20] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    static final public void tableElementList(TableDefinition.Builder builder) throws ParseException {
        jj_consume_token(LEFT_PAREN);
        tableElement(builder);
        label_6:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case COMMA: {
                    ;
                    break;
                }
                default:
                    jj_la1[21] = jj_gen;
                    break label_6;
            }
            jj_consume_token(COMMA);
            tableElement(builder);
        }
        jj_consume_token(RIGHT_PAREN);
    }

    static final public void tableElement(TableDefinition.Builder builder) throws ParseException {
        ColumnDefinition column;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case LEGAL_IDENTIFIER: {
                column = columnDefinition();
                builder.addColumn(column);
                break;
            }
            case PRIMARY:
            case FOREIGN: {
                tableConstraintDefinition(builder);
                break;
            }
            default:
                jj_la1[22] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    static final public ColumnDefinition columnDefinition() throws ParseException {
        ColumnDefinition.Builder columnBuilder = new ColumnDefinition.Builder();
        String columnName;
        DataTypeDefinition dataType;
        columnName = columnName();
        columnBuilder.setColumnName(columnName);
        dataType = dataType();
        columnBuilder.setDataType(dataType);
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case NOT_NULL: {
                jj_consume_token(NOT_NULL);
                columnBuilder.setConstraint("not null");
                break;
            }
            default:
                jj_la1[23] = jj_gen;
                ;
        }
        {
            if ("" != null) return columnBuilder.create();
        }
        throw new Error("Missing return statement in function");
    }

    static final public void tableConstraintDefinition(TableDefinition.Builder builder) throws ParseException {
        ForeignKeyDefinition foreignKeyDefinition;
        ArrayList<String> primaryKeyList;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case PRIMARY: {
                primaryKeyList = primaryKeyConstraint();
                builder.setPrimaryKeys(primaryKeyList);
                break;
            }
            case FOREIGN: {
                foreignKeyDefinition = referentialConstraint();
                builder.addForeignKey(foreignKeyDefinition);
                break;
            }
            default:
                jj_la1[24] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    static final public ArrayList<String> primaryKeyConstraint() throws ParseException {
        ArrayList<String> compositePk;
        jj_consume_token(PRIMARY);
        jj_consume_token(KEY);
        compositePk = columnNameList();
        {
            if ("" != null) return compositePk;
        }
        throw new Error("Missing return statement in function");
    }

    static final public ForeignKeyDefinition referentialConstraint() throws ParseException {
        ForeignKeyDefinition.Builder fbuilder = new ForeignKeyDefinition.Builder();
        String _referencedTableName;
        ArrayList<String> _referencedColumn;
        ArrayList<String> _referencingColumn;
        jj_consume_token(FOREIGN);
        jj_consume_token(KEY);
        _referencingColumn = columnNameList();
        fbuilder.setReferencingColumn(_referencingColumn);
        jj_consume_token(REFERENCES);
        _referencedTableName = tableName();
        fbuilder.setReferencedTableName(_referencedTableName);
        _referencedColumn = columnNameList();
        fbuilder.setReferencedColumn(_referencedColumn);
        {
            if ("" != null) return fbuilder.create();
        }
        throw new Error("Missing return statement in function");
    }

    static final public void insertColumnsAndSource(InsertQuery.Builder builder) throws ParseException {
        ArrayList<String> _columnName = new ArrayList<String>();
        ArrayList<ComparableValue> _valueList;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case LEFT_PAREN: {
                _columnName = columnNameList();
                break;
            }
            default:
                jj_la1[25] = jj_gen;
                ;
        }
        _valueList = valueList();
        builder
                .setColumnName(_columnName)
                .setValueList(_valueList);
    }

    static final public ArrayList<ComparableValue> valueList() throws ParseException {
        ArrayList<ComparableValue> _valueList = new ArrayList<>();
        ComparableValue _value;
        jj_consume_token(VALUES);
        jj_consume_token(LEFT_PAREN);
        _value = value();
        _valueList.add(_value);
        label_7:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case COMMA: {
                    ;
                    break;
                }
                default:
                    jj_la1[26] = jj_gen;
                    break label_7;
            }
            jj_consume_token(COMMA);
            _value = value();
            _valueList.add(_value);
        }
        jj_consume_token(RIGHT_PAREN);
        {
            if ("" != null) return _valueList;
        }
        throw new Error("Missing return statement in function");
    }

    static final public ArrayList<String> columnNameList() throws ParseException {
        ArrayList<String> _columnNameList = new ArrayList<>();
        String _columnName;
        jj_consume_token(LEFT_PAREN);
        _columnName = columnName();
        _columnNameList.add(_columnName);
        label_8:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case COMMA: {
                    ;
                    break;
                }
                default:
                    jj_la1[27] = jj_gen;
                    break label_8;
            }
            jj_consume_token(COMMA);
            _columnName = columnName();
            _columnNameList.add(_columnName);
        }
        jj_consume_token(RIGHT_PAREN);
        {
            if ("" != null) return _columnNameList;
        }
        throw new Error("Missing return statement in function");
    }

    static final public DataTypeDefinition dataType() throws ParseException {
        DataType _dataType;
        int _charLength = 0;
        Token temp;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case INT: {
                jj_consume_token(INT);
                _dataType = DataType.INTEGER;
                break;
            }
            case CHAR: {
                jj_consume_token(CHAR);
                jj_consume_token(LEFT_PAREN);
                temp = jj_consume_token(INT_VALUE);
                jj_consume_token(RIGHT_PAREN);
                _dataType = DataType.CHARACTER;
                _charLength = Integer.parseInt(temp.image);
                break;
            }
            case DATE: {
                jj_consume_token(DATE);
                _dataType = DataType.DATE;
                break;
            }
            default:
                jj_la1[28] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) return new DataTypeDefinition(_dataType, _charLength);
        }
        throw new Error("Missing return statement in function");
    }

    static final public String tableName() throws ParseException {
        Token _tableName;
        _tableName = jj_consume_token(LEGAL_IDENTIFIER);
        {
            if ("" != null) return _tableName.toString().toUpperCase();
        }
        throw new Error("Missing return statement in function");
    }

    static final public String columnName() throws ParseException {
        Token _columnName;
        _columnName = jj_consume_token(LEGAL_IDENTIFIER);
        {
            if ("" != null) return _columnName.toString().toUpperCase();
        }
        throw new Error("Missing return statement in function");
    }

    static final public ComparableValue value() throws ParseException {
        ComparableValue _value;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case NULL: {
                jj_consume_token(NULL);
                _value = new ComparableValue(DataType.CHARACTER, null);
                break;
            }
            case INT_VALUE:
            case DATE_VALUE:
            case CHAR_STRING: {
                _value = comparableValue();
                break;
            }
            default:
                jj_la1[29] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) return _value;
        }
        throw new Error("Missing return statement in function");
    }

    static private boolean jj_2_1(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return (!jj_3_1());
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(0, xla);
        }
    }

    static private boolean jj_2_2(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return (!jj_3_2());
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(1, xla);
        }
    }

    static private boolean jj_2_3(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return (!jj_3_3());
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(2, xla);
        }
    }

    static private boolean jj_2_4(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return (!jj_3_4());
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(3, xla);
        }
    }

    static private boolean jj_2_5(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return (!jj_3_5());
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(4, xla);
        }
    }

    static private boolean jj_2_6(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return (!jj_3_6());
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(5, xla);
        }
    }

    static private boolean jj_3R_12() {
        Token xsp;
        xsp = jj_scanpos;
        if (!jj_scan_token(35)) return false;
        jj_scanpos = xsp;
        if (!jj_scan_token(37)) return false;
        jj_scanpos = xsp;
        if (!jj_scan_token(36)) return false;
        jj_scanpos = xsp;
        if (!jj_scan_token(38)) return false;
        jj_scanpos = xsp;
        if (!jj_scan_token(39)) return false;
        jj_scanpos = xsp;
        if (jj_scan_token(40)) return true;
        return false;
    }

    static private boolean jj_3R_9() {
        if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
        return false;
    }

    static private boolean jj_3R_19() {
        if (jj_scan_token(DATE_VALUE)) return true;
        return false;
    }

    static private boolean jj_3_5() {
        if (jj_3R_9()) return true;
        if (jj_scan_token(PERIOD)) return true;
        return false;
    }

    static private boolean jj_3R_18() {
        if (jj_scan_token(CHAR_STRING)) return true;
        return false;
    }

    static private boolean jj_3R_17() {
        if (jj_scan_token(INT_VALUE)) return true;
        return false;
    }

    static private boolean jj_3R_15() {
        Token xsp;
        xsp = jj_scanpos;
        if (!jj_3R_17()) return false;
        jj_scanpos = xsp;
        if (!jj_3R_18()) return false;
        jj_scanpos = xsp;
        if (jj_3R_19()) return true;
        return false;
    }

    static private boolean jj_3R_14() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_5()) jj_scanpos = xsp;
        if (jj_3R_16()) return true;
        return false;
    }

    static private boolean jj_3R_10() {
        if (jj_3R_11()) return true;
        if (jj_3R_12()) return true;
        if (jj_3R_11()) return true;
        return false;
    }

    static private boolean jj_3R_13() {
        if (jj_3R_15()) return true;
        return false;
    }

    static private boolean jj_3_3() {
        if (jj_3R_9()) return true;
        if (jj_scan_token(PERIOD)) return true;
        return false;
    }

    static private boolean jj_3_6() {
        if (jj_3R_9()) return true;
        if (jj_scan_token(PERIOD)) return true;
        return false;
    }

    static private boolean jj_3R_16() {
        if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
        return false;
    }

    static private boolean jj_3R_11() {
        Token xsp;
        xsp = jj_scanpos;
        if (!jj_3R_13()) return false;
        jj_scanpos = xsp;
        if (jj_3R_14()) return true;
        return false;
    }

    static private boolean jj_3_4() {
        if (jj_3R_10()) return true;
        return false;
    }

    static private boolean jj_3_1() {
        if (jj_scan_token(NEWLINE)) return true;
        return false;
    }

    static private boolean jj_3_2() {
        if (jj_scan_token(NEWLINE)) return true;
        return false;
    }

    static private boolean jj_initialized_once = false;
    /**
     * Generated Token Manager.
     */
    static public SimpleDBMSParserTokenManager token_source;
    static SimpleCharStream jj_input_stream;
    /**
     * Current token.
     */
    static public Token token;
    /**
     * Next token.
     */
    static public Token jj_nt;
    static private int jj_ntk;
    static private Token jj_scanpos, jj_lastpos;
    static private int jj_la;
    static private int jj_gen;
    static final private int[] jj_la1 = new int[30];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;

    static {
        jj_la1_init_0();
        jj_la1_init_1();
    }

    private static void jj_la1_init_0() {
        jj_la1_0 = new int[]{0x0, 0x6bc20, 0x0, 0x6bc00, 0x6bc00, 0x100000, 0x100000, 0x0, 0x0, 0x200000, 0x0, 0x200000, 0x400000, 0x800000, 0x2000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80000000, 0x0, 0x18000000, 0x80000000, 0x18000000, 0x0, 0x0, 0x0, 0x1c0, 0x0,};
    }

    private static void jj_la1_init_1() {
        jj_la1_1 = new int[]{0x400, 0x0, 0x400, 0x0, 0x0, 0x0, 0x0, 0x2000, 0x200002, 0x0, 0x2000, 0x0, 0x0, 0x0, 0x0, 0x238800, 0x200000, 0x238000, 0x1f8, 0x38000, 0x1, 0x2000, 0x200000, 0x0, 0x0, 0x800, 0x2000, 0x2000, 0x0, 0x38001,};
    }

    static final private JJCalls[] jj_2_rtns = new JJCalls[6];
    static private boolean jj_rescan = false;
    static private int jj_gc = 0;

    /**
     * Constructor with InputStream.
     */
    public SimpleDBMSParser(java.io.InputStream stream) {
        this(stream, null);
    }

    /**
     * Constructor with InputStream and supplied encoding
     */
    public SimpleDBMSParser(java.io.InputStream stream, String encoding) {
        if (jj_initialized_once) {
            System.out.println("ERROR: Second call to constructor of static parser.  ");
            System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
            System.out.println("	   during parser generation.");
            throw new Error();
        }
        jj_initialized_once = true;
        try {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new SimpleDBMSParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 30; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Reinitialise.
     */
    static public void ReInit(java.io.InputStream stream) {
        ReInit(stream, null);
    }

    /**
     * Reinitialise.
     */
    static public void ReInit(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 30; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Constructor.
     */
    public SimpleDBMSParser(java.io.Reader stream) {
        if (jj_initialized_once) {
            System.out.println("ERROR: Second call to constructor of static parser. ");
            System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
            System.out.println("	   during parser generation.");
            throw new Error();
        }
        jj_initialized_once = true;
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new SimpleDBMSParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 30; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Reinitialise.
     */
    static public void ReInit(java.io.Reader stream) {
        if (jj_input_stream == null) {
            jj_input_stream = new SimpleCharStream(stream, 1, 1);
        } else {
            jj_input_stream.ReInit(stream, 1, 1);
        }
        if (token_source == null) {
            token_source = new SimpleDBMSParserTokenManager(jj_input_stream);
        }

        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 30; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Constructor with generated Token Manager.
     */
  public SimpleDBMSParser(SimpleDBMSParserTokenManager tm) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 30; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SimpleDBMSParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 30; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   if (++jj_gc > 100) {
		 jj_gc = 0;
		 for (int i = 0; i < jj_2_rtns.length; i++) {
		   JJCalls c = jj_2_rtns[i];
		   while (c != null) {
			 if (c.gen < jj_gen) c.first = null;
			 c = c.next;
		   }
		 }
	   }
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error {
    @Override
    public Throwable fillInStackTrace() {
      return this;
    }
  }
  static private final LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
	 if (jj_scanpos == jj_lastpos) {
	   jj_la--;
	   if (jj_scanpos.next == null) {
		 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
	   } else {
		 jj_lastpos = jj_scanpos = jj_scanpos.next;
	   }
	 } else {
	   jj_scanpos = jj_scanpos.next;
	 }
	 if (jj_rescan) {
	   int i = 0; Token tok = token;
	   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
	   if (tok != null) jj_add_error_token(kind, i);
	 }
	 if (jj_scanpos.kind != kind) return true;
	 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
	 return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  static private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
	 if (pos >= 100) {
		return;
	 }

	 if (pos == jj_endpos + 1) {
	   jj_lasttokens[jj_endpos++] = kind;
	 } else if (jj_endpos != 0) {
	   jj_expentry = new int[jj_endpos];

	   for (int i = 0; i < jj_endpos; i++) {
		 jj_expentry[i] = jj_lasttokens[i];
	   }

	   for (int[] oldentry : jj_expentries) {
		 if (oldentry.length == jj_expentry.length) {
		   boolean isMatched = true;

		   for (int i = 0; i < jj_expentry.length; i++) {
			 if (oldentry[i] != jj_expentry[i]) {
			   isMatched = false;
			   break;
			 }

		   }
		   if (isMatched) {
			 jj_expentries.add(jj_expentry);
			 break;
		   }
		 }
	   }

	   if (pos != 0) {
		 jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	   }
	 }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[59];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 30; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 59; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 jj_endpos = 0;
	 jj_rescan_token();
	 jj_add_error_token(0, 0);
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  static private boolean trace_enabled;

/** Trace enabled. */
  static final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
	 jj_rescan = true;
	 for (int i = 0; i < 6; i++) {
	   try {
		 JJCalls p = jj_2_rtns[i];

		 do {
		   if (p.gen > jj_gen) {
			 jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
			 switch (i) {
			   case 0: jj_3_1(); break;
			   case 1: jj_3_2(); break;
			   case 2: jj_3_3(); break;
			   case 3: jj_3_4(); break;
			   case 4: jj_3_5(); break;
			   case 5: jj_3_6(); break;
			 }
		   }
		   p = p.next;
		 } while (p != null);

		 } catch(LookaheadSuccess ls) { }
	 }
	 jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
	 JJCalls p = jj_2_rtns[index];
	 while (p.gen > jj_gen) {
	   if (p.next == null) { p = p.next = new JJCalls(); break; }
	   p = p.next;
	 }

	 p.gen = jj_gen + xla - jj_la; 
	 p.first = token;
	 p.arg = xla;
  }

  static final class JJCalls {
	 int gen;
	 Token first;
	 int arg;
	 JJCalls next;
  }

}
